open Cart_pole
open Pendulum
open Gym

(** MISC **)

let gaussian (m, s) = Distribution.gaussian m s

let node print_stats name (m, s) =
  print_string ("("^name^": mean =  ");
  print_float m;
  print_string " var = ";
  print_float s;
  print_string ")";
  print_newline ()

let node print_coefs (p, i, d) =
  print_string " p = ";
  print_float p;
  print_string " i = ";
  print_float i;
  print_string " d = ";
  print_float d;
  print_newline ()


(** PID controller for the cart-pole example **)

(* A Discrete PID controller *)
let node controller (angle, (p,i,d)) = action where
  rec e = angle -. (0.0 fby theta)
  and theta = p *. e +. i *. integr(0., e) +. d *. deriv(e)
  and action = if theta > 0. then Right else Left

(* Sample coefs from given priors *)
let node model (prob, (obs_init, p_prior, i_prior, d_prior)) = p, (i, d) where
  rec init p = Infer.sample(prob, p_prior)
  and init i = Infer.sample(prob, i_prior)
  and init d = Infer.sample(prob, d_prior)
  and obs = simple_pendulum (obs_init,  Right fby action)
  and action = controller (obs.pole_angle, (p,i,d))
  and () = Infer.factor(prob, -10. *. abs_float (obs.pole_angle))

(* Restart inference with updated priors when stddev of p_dist is halved *)
let node pid_bayes_update particles (priors, obs, stop) = pid_dist where
  rec p_init, i_init, d_init = priors
  and init p_stats = p_init
  and init p_prior = gaussian p_init
  and init i_prior = gaussian i_init
  and init d_prior = gaussian d_init
  and automaton
      | Learn ->
          do pid_dist = Infer.infer particles model (obs, p_prior, i_prior, d_prior)
          and p_dist, id_dist = Distribution.split pid_dist
          and i_dist, d_dist = Distribution.split id_dist
          and ps = Distribution.stats_float p_dist
          and ds = Distribution.stats_float d_dist
          and is = Distribution.stats_float i_dist
          until (snd ps < snd p_stats /. 2.) then Update(ps, is, ds)
      | Update(ps, is, ds) ->
          do p_stats = ps
          and p_prior = gaussian ps
          and i_prior = gaussian is
          and d_prior = gaussian ds
          then Learn


(* Alternative implementation: push the automaton in the model,
   estimate distributions stats outside *)
let node model2 (prob, (obs_init, ps, is, ds)) = p, (i, d) where
  rec automaton
      | Update ->
          do p_stats = ps
          and p = Infer.sample(prob, gaussian ps)
          and i = Infer.sample(prob, gaussian is)
          and d = Infer.sample(prob, gaussian ds)
          then Learn
      | Learn -> local action, obs in
          do obs = simple_pendulum (obs_init,  Right fby action)
          and action = controller (obs.pole_angle, (p,i,d))
          and () = Infer.factor(prob, -10. *. abs_float (obs.pole_angle))
          and () = draw_obs_back obs
          until (snd ps < snd p_stats /. 2.) then Update


(* At each step: compute the distribution and the corresponding stats *)
let node pid_bayes_update2 particles (priors, obs, stop) = pid_dist where
  rec p_init, i_init, d_init = priors
  and pid_dist = Infer.infer particles model2 (obs, ps, is, ds)
  and p_dist, id_dist = Distribution.split pid_dist
  and i_dist, d_dist = Distribution.split id_dist
  and ps = p_init fby Distribution.stats_float p_dist
  and is = i_init fby Distribution.stats_float i_dist
  and ds = d_init fby Distribution.stats_float d_dist


(* let node model3 (prob, (obs_init, update)) = p, (i, d) where *)
(*   rec init p_stats = ps *)
(*   and init p = Infer.sample(prob, gaussian ps) *)
(*   and init i = Infer.sample(prob, gaussian is) *)
(*   and init d = Infer.sample(prob, gaussian ds) *)
(*   and obs = simple_pendulum (obs_init,  Right fby action) *)
(*   and action = controller (obs.pole_angle, (p,i,d)) *)
(*   and () = Infer.factor(prob, -10. *. abs_float (obs.pole_angle)) *)
(*   and present update(ps, is, ds) -> *)
(*       do p = Infer.sample(prob, gaussian ps) *)
(*       and i = Infer.sample(prob, gaussian is) *)
(*       and d = Infer.sample(prob, gaussian ds) done *)


(* Modular restart: discard coefs for episods with score < 100.
   When stddev of p_dist < 0.1 fix coefs.
   In fixed mode, after three episods with score < 100 restart learning *)
let node learn_control particles
    (pid_model: int -S-> 'a -D-> 'b Distribution.t) (priors_init, obs, stop) = action where
  rec init priors = priors_init
  and (p, (i, d)) = Distribution.draw pid_dist
  and action = controller (obs.pole_angle, (p, i, d))
  and reset score = 0 fby (score + 1) every stop
  and present fix() -> do () = print_coefs (p, i, d) done
  and automaton
      | Learn ->
          do pid_dist = pid_model particles (priors, obs, stop)
          and p_dist, _ =  Distribution.split pid_dist
          and ps = Distribution.stats_float p_dist
          until (stop && (0 fby score < 50)) then Learn
          else (snd ps < 0.01) then
            do () = print_endline "End Learning"
            and emit fix
          in Control
      | Control -> local cpt in
          do cpt = 0 fby if stop && (0 fby score < 100) then cpt + 1 else cpt
          until (cpt > 3) then do () = print_endline "Restart Learning" in Learn


let node pid_main () = () where
  rec p_init = (0., 0.1)
  and i_init = (0., 0.1)
  and d_init = (0., 0.1)
  and obs, _, stop = cart_pole_gym true (Right fby action)
  and action = learn_control 2000 pid_bayes_update2 ((p_init, i_init, d_init), obs, stop)
  and display = draw_obs_front obs
