(*
 * Copyright 2018-2020 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *)

open Probzelus
open Distribution
open Display
open Infer_pf
(* open Infer_importance *)

(* noisy observation of the mouse position. It is a gaussian centered on the *)
(* exact position *)
let node sensor () = obs where
  rec (x, y) = Display.mouse_pos ()
  and in_bound = 0 < x && x < 400 && 0 < y && y < 400
  and obs = present in_bound -> observe_state (float x, float y)

(* let proba sensor () = obs where *)
(*   rec x = sample (sph_gaussian([200.; 200.] -> pre x, speed)) *)
(*   and obs = sample (sph_gaussian(x, noise)) *)

let node display (obs, pos_dist) =
  Display.draw_point_dist pos_dist;
  Display.draw_point Graphics.red obs;
  Display.clear ()

(* the expected position [p] of the mouse is searched arround the previous *)
(* one supposing that the motion speed of the mouse is bounded *)
let proba hmm obs = p where
  rec p = sample (sph_gaussian(obs fby p, speed))
  and () = factor (Distribution.score(sph_gaussian(p, noise), obs))
  and init t = traj_init ()
  and t = traj_add (last t, p)
  and () = traj_draw t

let node once n = ok where
  rec init cpt = 1 and cpt = if ok then 1 else last cpt + 1
  and ok = last cpt = n

let proba hmm_momentum(obs) = p where
  rec last_p = obs fby p
  and momentum = (last_p -: (obs fby last_p)) *: 0.7
  and p = sample (sph_gaussian(last_p +: momentum, speed))
  and () = factor(Distribution.score (sph_gaussian(p, noise), obs))
  and init t = traj_init ()
  and t = traj_add (last t, p)
  and () = traj_draw t


let proba hmm_reset_automaton(obs) = p where
  rec automaton
      | HMM(p_init) ->
          do p = hmm_momentum(obs)
          and last_obs = p_init fby obs
          until
            (norm (obs -: last_obs) > (2. *. norm(speed +: noise))) then HMM(obs)
       init HMM(obs)

let proba hmm_reset(obs) = p where
  rec reset p = hmm(obs)
        and last_obs = obs fby obs
        and n = norm (obs -: last_obs)
      every false fby (n > norm(speed +: noise))
  and p_init = Display.p_init -> obs

let node main () =
  let obs = sensor () in
  (* let emit obs = fst (gen sensor ()) in *)
  present obs(o) ->
    let pos_dist = infer 1000 hmm(* _momentum *) o in
    display(o, pos_dist)
  else ()

(* let node every_n k = *)
(*   let rec ok = false -> pre cpt = 0 *)
(*   and cpt = k -> if ok then k else pre cpt - 1 in *)
(*   ok *)

(* let node main () = *)
(*   let obs = sensor () in *)
(*   present obs(o) -> *)
(*     let pos_dist = *)
(*       reset *)
(*      infer 1000 hmm_momentum(true, o) *)
(*       every every_n 10 in *)
(*     display(o, pos_dist) *)
(*   else () *)
