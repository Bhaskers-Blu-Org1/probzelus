open Probzelus
open Distribution
open Infer_ds_gc
open Zelus_owl
open Owl



let diag l = Mat.diagm (Lib.of_lists [l])
let pos x = Mat.get x 0 0

(* Using variable names matching here:
  https://en.wikipedia.org/wiki/Linearâ€“quadratic_regulator
 *)
let lqr a b q r n =
  let p = Lib.dare a b q r in
  let btp = Mat.dot (Mat.transpose b) p in
  let f = Lib.linsolve
    (Mat.add r (Mat.dot btp b))
    (Mat.add (Mat.transpose n) (Mat.dot btp a))
  in Mat.mul_scalar f (-1.)

let a = Lib.of_lists
  [[ 1.0; 0.1; 0.0 ];
   [ 0.0; 1.0; 0.1 ];
   [ 0.0; 0.0; 0.0 ]]

let a_approx = Lib.of_lists
  [[ 1.0; 0.1; 0.0 ];
   [ 0.0; 1.0; 0.1 ];
   [ 0.0; 0.0; 0.000001 ]]

let b = Mat.eye 3
let q = diag [1.0; 0.1; 0.1]
let r = diag [1000.; 1000.; 1.0]
let n = Mat.zeros 3 3

let controller x =
  let k = lqr a_approx b q r n in
  Mat.dot k x

let x_init = diag [50.; 0.; 0.]
let init_sig = diag [10.; 0.001; 1.0]
let update_sig = diag [0.01; 0.01; 0.01]

let obs_acc = diag [0.; 0.; 1.0]
let obs_acc_approx = diag [0.0001; 0.0001; 1.0]
let obs_acc_gps = diag [1.0; 0.; 0.0]
let obs_acc_gps_approx = diag [1.0; 0.0001; 0.0001]
let obs_sig = diag [1.0; 1.0; 0.1]


let particles = 1000

let node env cmd = (xt, yt) where
  rec t = 0 -> (pre t) + 1
  and () = Lib.print yt
  and xt = draw (Distribution.mv_gaussian ((x_init, init_sig) -> (Mat.add cmd (Mat.dot a (pre xt)), update_sig)))
  and obs = present (t mod 50 = 0) -> obs_acc_gps else obs_acc
  and yt = draw (Distribution.mv_gaussian (Mat.dot obs xt, obs_sig))

let proba model (yt, cmd) = xt where
  rec t = 0 -> (pre t) + 1
  and xt = sample (mv_gaussian ((const x_init, init_sig) -> (const cmd +@~ const a *@~ pre xt, update_sig)))
  and () = observe (mv_gaussian ((const obs_acc_approx *@~ xt), obs_sig), yt)
  and present (t mod 50 = 0) -> do () = observe (mv_gaussian ((const obs_acc_gps_approx *@~ xt), obs_sig), yt) done

let node main () = () where
  rec t = 0 -> (pre t) + 1
  and (xt, yt) = env (Mat.zeros 3 1 -> (pre cmd))
  and cmd = controller xest
  and xest = mean_matrix (infer particles model (yt, (Mat.zeros 3 1 -> (pre cmd))))
  and err = 0. -> (pre err) +. (pos xt *. pos xt)
  and avg_err = err /. (float_of_int t)
  and xye = Lib.of_lists [[pos xt; pos yt; pos xest]]
  and res = (Mat.zeros 1 3) fby Mat.concat_vertical res xye
  and () = print_int t; print_string " >> "; print_float (avg_err); print_endline ""
  and present (t mod 51 = 50) -> do () = Lib.plot "plot_3pos.pdf" res done
