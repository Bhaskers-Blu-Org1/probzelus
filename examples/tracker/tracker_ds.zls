open Probzelus
open Distribution
open Infer_ds_gc
open Zelus_owl

(*
let id x = x
let const = id
let dot_mat (x, y) = Mat.dot x y
let add_mat (x, y) = Mat.add x y
let get (x, i, j) = Mat.get x i j
*)

let diagm l = Mat.diagm (Lib.of_lists [l])
let vec l = Lib.of_list l (List.length l) 1

let position x = Mat.get x 0 0
let acceleration x = Mat.get x 2 0
let speed x = Mat.get x 1 0


(* Using variable names matching here:
  https://en.wikipedia.org/wiki/Linearâ€“quadratic_regulator
 *)
let lqr a b q r n =
  let p = Linalg_d.dare a b q r in
  let btp = Mat.dot (Mat.transpose b) p in
  let f = Linalg_d.linsolve
    (Mat.add r (Mat.dot btp b))
    (Mat.add (Mat.transpose n) (Mat.dot btp a))
  in Mat.mul_scalar f (-1.)

let a = Lib.of_lists
  [[ 1.0; 0.1; 0.0 ];
   [ 0.0; 1.0; 0.1 ];
   [ 0.0; 0.0; 0.0 ]]

let a_approx = Lib.of_lists
  [[ 1.0; 0.1; 0.0 ];
   [ 0.0; 1.0; 0.1 ];
   [ 0.0; 0.0; 0.000001 ]]

let b = Mat.eye 3
let q = diagm [1.0; 0.1; 0.1]
let r = diagm [1000.; 1000.; 1.0]
let n = Mat.zeros 3 3

let controller x =
  let k = lqr a_approx b q r n in
  Mat.mul (Mat.dot k x) (Lib.of_list [0.; 0.; 1.] 3 1)

let x_init = Lib.of_list [50.; 0.; 0.5] 3 1
let init_sig = diagm [10.; 0.001; 1.0]
let state_noise = diagm [0.01; 0.01; 0.01]

let obs_acc = diagm [0.; 0.; 1.0]
let obs_acc_approx = diagm [0.0001; 0.0001; 1.0]
let obs_acc_gps = diagm [1.0; 0.; 1.0]
let obs_acc_gps_approx = diagm [1.0; 0.0001; 1.0]
let obs_gps_approx = diagm [1.0; 0.0001; 0.0001]
let obs_noise = diagm [1.0; 1.0; 0.1]


let particles = 1

let node env_noisy_integr noise x_init acc = x where
  rec mu = x_init fby Mat.add acc (Mat.dot a x)
  and x = draw (Distribution.mv_gaussian (mu, noise))

let node env (call_gps, cmd) = xt, acc, gps where
  rec xt = env_noisy_integr state_noise x_init cmd
  and present call_gps -> do emit gps = draw (Distribution.gaussian (position xt, 1.0)) done
  and acc = draw (Distribution.gaussian (acceleration xt, 0.1))


let proba noisy_integr noise x_init acc = x where
  rec mu = (const x_init) fby mat_add (const acc, mat_dot (const a, x))
  and x = sample (mv_gaussian (mu, noise))


(*
let proba model (acc, gps, cmd) = x where
  rec x = noisy_integr state_noise x_init cmd
  and () = observe (mv_gaussian (dot_mat (const obs_acc_approx, x), obs_noise), vec [0.; 0.; acc])
  and present gps(p) ->
    do () = observe (mv_gaussian (dot_mat (const obs_gps_approx, x), obs_noise), vec [p; 0.; 0.]) done
*)

let proba model (acc, gps, cmd) = x where
  rec x = noisy_integr state_noise x_init cmd
  and () = observe (gaussian (vec_get (x, 2), 0.1), acc)
  and present gps(p) -> do () = observe (gaussian (vec_get (x, 0), 1.0), p) done

let node main () = () where
  rec t = 1 fby t + 1
  and call_gps = (t mod 50 = 0)
  and xt, acc, gps = env (call_gps, cmd)
  and xest = mean_matrix (infer particles model (acc, gps, cmd))
  and cmd = controller (Mat.zeros 3 1 fby xest)
  and err = 0. -> (pre err) +. (position xt *. position xt)
  and avg_err = err /. (float_of_int t)
  and yt = present gps(p) -> p else 0.
  and xye = Lib.of_lists [[position xt; yt; position xest]]
  and res = (Mat.zeros 1 3) fby Mat.concat_vertical res xye
  and () = print_int t; print_string " >> "; print_float (avg_err); print_endline ""
  and present (t mod 51 = 50) -> do () = Lib.plot "plot_3pos.pdf" res done
